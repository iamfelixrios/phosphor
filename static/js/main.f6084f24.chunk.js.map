{"version":3,"sources":["components/Phosphor/index.tsx","components/Teletype/index.tsx","components/Link/index.tsx","components/Text/index.tsx","components/Bitmap/index.tsx","components/Prompt/index.tsx","components/Toggle/index.tsx","components/Modal/index.tsx","components/Scanlines/index.tsx","serviceWorker.ts","index.tsx"],"names":["DialogType","ScreenType","ScreenDataType","ScreenDataState","AppStatus","Teletype","props","_cursorInterval","_animateTimerId","_cursorRef","_cursorY","React","createRef","done","autocomplete","paused","autostart","speed","state","index","char","active","_animate","bind","_updateState","this","text","className","visible","substr","cursor","hidden","css","join","trim","ref","_onComplete","setState","prevProps","prevState","clearTimeout","_clearAnimateTimer","_getCursorPosition","window","setTimeout","onNewLine","y","current","top","offsetTop","nextChar","nextActive","nextDone","nextPaused","length","onComplete","Component","Link","target","onClick","onRendered","useEffect","e","shiftKey","Text","STEPS","Bitmap","_canvasRef","_currentStep","_clearAnimationTimer","clearInterval","loading","image","Image","_loadImage","resolution","canvas","ctx","getContext","w","width","h","height","dw","dh","imageSmoothingEnabled","drawImage","setInterval","_resampleImage","src","onload","Prompt","disabled","prompt","commands","onCommand","useRef","useState","value","setValue","handleKeyDown","preventDefault","key","toLowerCase","slice","command","find","element","action","handleCommand","match","document","addEventListener","removeEventListener","focus","Toggle","states","setActive","handleClick","useCallback","findIndex","forEach","next","Modal","onClose","map","Scanlines","Phosphor","_containerRef","_lineheight","_colwidth","screens","dialogs","activeScreenId","activeElementId","activeDialogId","loadingQueue","status","Unset","renderScanlines","_changeScreen","_setElementState","_handlePromptCommand","_handleTeletypeNewLine","_handleLinkClick","_renderScreen","_renderDialog","_parseScreens","_parseDialogs","json","_buildScreen","_setActiveScreen","_buildDialog","id","type","_getDialogType","content","Alert","Confirm","Dialog","Unknown","activeScreen","_activateScreen","screen","_getScreen","Active","Static","Screen","_getScreenType","_parseScreenContent","flat","Ready","_renderActiveElement","Done","_renderStaticElement","_parseScreenContentElement","_generateScreenData","nanoid","onLoad","push","Unloaded","alt","split","_activateNextScreenData","item","handleRendered","targetScreen","_unloadScreen","activeElement","activeIndex","firstData","dialogId","args","_toggleDialog","console","log","dialog","linkTarget","Boolean","location","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.f6084f24.chunk.js","sourcesContent":["import React, { Component, ReactElement } from \"react\";\n\n// css\nimport \"./style.scss\";\n\n// modules\nimport { nanoid } from \"nanoid\";\n\n// components\nimport Teletype from \"../Teletype\";\nimport Link from \"../Link\";\nimport Text from \"../Text\";\nimport Bitmap from \"../Bitmap\";\nimport Prompt, { PROMPT_DEFAULT } from \"../Prompt\";\nimport Toggle from \"../Toggle\";\n\nimport Modal from \"../Modal\";\nimport Scanlines from \"../Scanlines\";\n\n// import sample data for development purposes\nimport json from \"../../data/sample.json\";\n\ninterface AppState {\n    screens: Screen[];\n    dialogs: any[];\n    activeScreenId: string;\n    activeElementId: string; // which element, if any, is active\n    activeDialogId: string; // which element, if any, is active\n    loadingQueue: any[];\n    status: AppStatus;\n\n    renderScanlines: boolean; // should scanlines be enabled?\n}\n\nenum DialogType {\n    Unknown = 0,\n    Alert, // simple message box\n    Confirm, // yes/no box; currently unsupported\n    Dialog, // has arbitrary content; currently unsupported\n}\n\ninterface Dialog {\n    id: string;\n    type: DialogType;\n\n    [key: string]: any; // arbitrary members\n}\n\nenum ScreenType {\n    Unknown = 0,\n    Screen,\n    Static,\n}\n\nenum ScreenDataType {\n    Unknown = 0,\n    Text,\n    Link,\n    Bitmap,\n    Prompt,\n    Toggle,\n}\n\nenum ScreenDataState {\n    Unloaded = 0,\n    Ready,\n    Active,\n    Done,\n}\n\ninterface ScreenData {\n    id: string;\n    type: ScreenDataType;\n    state: ScreenDataState;\n\n    [key: string]: any; // arbitrary members\n}\n\ninterface Screen {\n    id: string;\n    type: ScreenType;\n    content: ScreenData[];\n}\n\nenum AppStatus {\n    Unset = 0,\n    Ready,\n    Active,\n    Done,\n}\n\nclass Phosphor extends Component<any, AppState> {\n    private _containerRef: React.RefObject<HTMLElement>;\n    private _lineheight: number = null;\n    private _colwidth: number = null;\n\n    constructor(props: any) {\n        super(props);\n\n        this._containerRef = React.createRef<HTMLElement>();\n\n        this.state = {\n            screens: [],\n            dialogs: [],\n            activeScreenId: null,\n            activeElementId: null,\n            activeDialogId: null,\n            loadingQueue: [],\n            status: AppStatus.Unset,\n            renderScanlines: true, // TODO: support option to disable this effect\n        };\n\n        this._changeScreen = this._changeScreen.bind(this);\n        this._setElementState = this._setElementState.bind(this);\n        this._handlePromptCommand = this._handlePromptCommand.bind(this);\n        this._handleTeletypeNewLine = this._handleTeletypeNewLine.bind(this);\n        this._handleLinkClick = this._handleLinkClick.bind(this);\n    }\n\n    public render(): ReactElement {\n        const {\n            activeScreenId,\n            activeDialogId,\n            renderScanlines,\n        } = this.state;\n\n        return (\n            <div className=\"phosphor\">\n                <section className={\"__main__\"} ref={this._containerRef}>\n                    {activeScreenId && this._renderScreen()}\n                </section>\n\n                {activeDialogId && this._renderDialog()}\n\n                {/* scanlines should be the last child */}\n                {renderScanlines && <Scanlines />}\n            </div>\n\n        );\n    }\n\n    // public react events\n    public componentDidMount(): void {\n        // parse the data & prep the screens\n        this._parseScreens();\n        this._parseDialogs();\n    }\n\n    // private methods\n    private _parseScreens(): void {\n        const screens = json.screens.map((element) => {\n            return this._buildScreen(element);\n        });\n\n        if (!screens.length) {\n            return;\n        }\n\n        // todo: support config option to set starting screen\n        const activeScreen = 0;\n        this.setState({\n            screens,\n        }, () => this._setActiveScreen(activeScreen));\n    }\n\n    private _parseDialogs(): void {\n        const dialogs = json.dialogs.map((element) => {\n            return this._buildDialog(element);\n        });\n\n        if (!dialogs.length) {\n            return;\n        }\n\n        this.setState({\n            dialogs,\n        });\n    }\n\n    private _buildDialog(src: any): Dialog {\n        const id = src.id || null;\n        const type = this._getDialogType(src.type);\n\n        // TODO: support other dialog types\n        let content: any [] = null;\n        if (type === DialogType.Alert) {\n            content = src.content;\n        }\n\n        return {\n            id,\n            type,\n            content,\n        };\n    }\n\n    private _getDialogType(type: string): DialogType {\n        switch (type.toLowerCase()) {\n            case \"alert\":\n                return DialogType.Alert;\n\n            case \"confirm\":\n                return DialogType.Confirm;\n\n            case \"dialog\":\n                return DialogType.Dialog;\n\n            default:\n                return DialogType.Unknown;\n        }\n    }\n\n    private _setActiveScreen(index: number): void {\n        const { screens, } = this.state;\n        const activeScreen = screens[index].id\n        this.setState({\n            activeScreenId: activeScreen,\n        }, () => this._activateScreen());\n    }\n\n    // we're off to the races!\n    private _activateScreen(): void {\n        const screen = this._getScreen(this.state.activeScreenId);\n\n        // update the app status\n        const status = AppStatus.Active;\n\n        // depending on the screen type, we perform different actions here\n        switch (screen.type) {\n            case ScreenType.Static:\n                this.setState({\n                    status,\n                });\n                break;\n\n            case ScreenType.Screen:\n                screen.content[0].state = ScreenDataState.Active;\n\n                this.setState({\n                    status,\n                    activeElementId: screen.content[0].id,\n                });\n                break;\n\n            default: // do nothing\n                break;\n        }\n    }\n\n    private _buildScreen(src: any): Screen {\n        // try to parse & build the screen\n        const id = src.id || null;\n        const type = this._getScreenType(src.type);\n        const content = this._parseScreenContent(src.content).flat(); // flatten to one dimension\n\n        // if this screen is invalid for any reason, skip it\n        if (!id || !type) {\n            return;\n        }\n\n        return {\n            id,\n            type,\n            content,\n        };\n    }\n\n    private _getScreenType(type: string): ScreenType {\n        switch (type.toLowerCase()) {\n            case \"screen\":\n                return ScreenType.Screen;\n\n            case \"static\":\n                return ScreenType.Static;\n\n            default:\n                return ScreenType.Unknown;\n        }\n    }\n\n    private _renderScreen(): ReactElement[] {\n        // get the active screen\n        const screen = this._getScreen(this.state.activeScreenId);\n        if (!screen) {\n            return;\n        }\n\n        // loop through the screen contents & render each element\n        return screen.content.map((element, index) => {\n            // wrap a div around the element based on its state\n\n            // if it's ready, do nothing\n            if (element.state === ScreenDataState.Ready) {\n                return null;\n            }\n\n            // if it's active, render it animated\n            if (element.state === ScreenDataState.Active) {\n                return (\n                    <div className=\"active\" key={index}>\n                        {this._renderActiveElement(element, index)}\n                    </div>\n                );\n            }\n\n            // if it's done, render it static\n            if (element.state === ScreenDataState.Done) {\n                return (\n                    <div className=\"rendered\" key={index}>\n                        {this._renderStaticElement(element, index)}\n                    </div>\n                );\n            }\n\n            // unknown\n            return null;\n        });\n    }\n\n    private _getScreen(id: string): Screen {\n        return this.state.screens.find(element => element.id === id);\n    }\n\n    private _parseScreenContent(content: any[]): ScreenData[] {\n        if (!content) {\n            return [];\n        }\n\n        const parsed = content.map(element => this._parseScreenContentElement(element)).flat();\n        return parsed.map(element => this._generateScreenData(element));\n    }\n\n    private _generateScreenData(element: any): ScreenData {\n        // TODO: build the data object based on the element type\n        // e.g. typeof element === \"string\" --> create a new ScreenData Text object\n        const id = nanoid();\n\n        // if an element has \"load\" property, its requires more work\n        // to prepare so it's can't yet be considered \"ready\".\n        const onLoad = element.onLoad || null;\n        // if an element requires more loading, we'll shove its id in the queue\n        if (onLoad) {\n            const loadingQueue = [...this.state.loadingQueue];\n            loadingQueue.push(element.id);\n            this.setState({\n                loadingQueue\n            });\n        }\n        const state = onLoad ? ScreenDataState.Unloaded : ScreenDataState.Ready;\n\n        // text-only elements can be added as strings in the JSON data; they don't need any object wrappers\n        if (typeof element === \"string\") {\n            return {\n                id,\n                type: ScreenDataType.Text,\n                text: element,\n                state,\n                onLoad,\n            }\n        }\n\n        // everything else requires a wrapper containing a \"type\" attribute, so we'll need to parse those here\n        if (!element.type) {\n            return;\n        }\n\n        switch (element.type.toLowerCase()) {\n            case \"text\":\n                return {\n                    id,\n                    type: ScreenDataType.Text,\n                    text: element.text,\n                    className: element.className,\n                    state,\n                    onLoad,\n                }\n\n            case \"link\":\n                return {\n                    id,\n                    type: ScreenDataType.Link,\n                    target: element.target,\n                    className: element.className,\n                    text: element.text,\n                    state,\n                    onLoad,\n                };\n\n            case \"image\":\n            case \"bitmap\":\n                return {\n                    id,\n                    type: ScreenDataType.Bitmap,\n                    src: element.src,\n                    alt: element.alt,\n                    className: element.className,\n                    state,\n                    onLoad,\n                };\n\n            case \"prompt\":\n                return {\n                    id,\n                    type: ScreenDataType.Prompt,\n                    prompt: element.prompt || PROMPT_DEFAULT,\n                    className: element.className,\n                    commands: element.commands,\n                    state,\n                    onLoad,\n                };\n\n            case \"toggle\":\n                return {\n                    id,\n                    type: ScreenDataType.Toggle,\n                    states: element.states,\n                    state,\n                };\n\n            default:\n                return;\n        }\n    }\n\n    private _parseScreenContentElement(element: any): any {\n        // if the element is a string, we'll want to\n        // split it into chunks based on the new line character\n        if (typeof element === \"string\") {\n            return element.split(\"\\n\");\n        }\n\n        // otherwise, just return the element\n        return element;\n    }\n\n    // based on the current active ScreenData, render the corresponding active element\n    private _renderActiveElement(element: any, key: number): ReactElement {\n        const type = element.type;\n\n        // if the element is text-based, like text or Link, render instead a\n        // teletype component\n        if (type === ScreenDataType.Text || type === ScreenDataType.Link || type === ScreenDataType.Prompt\n        ) {\n            const text = type === ScreenDataType.Prompt ? element.prompt : element.text;\n            const handleRendered = () => this._activateNextScreenData();\n            return (\n                <Teletype\n                    key={key}\n                    text={text}\n                    onComplete={handleRendered}\n                    onNewLine={this._handleTeletypeNewLine}\n                    autocomplete={false}\n                    className={element.className}\n                />\n            );\n        }\n\n        // the toggle gets its text from the states array\n        if (type === ScreenDataType.Toggle) {\n            const text = element.states.find((item: any) => item.active === true).text;\n            const handleRendered = () => this._activateNextScreenData();\n            return (\n                <Teletype\n                    key={key}\n                    text={text}\n                    onComplete={handleRendered}\n                    onNewLine={this._handleTeletypeNewLine}\n                    autocomplete={false}\n                    className={element.className}\n                />\n            );\n        }\n\n        if (type === ScreenDataType.Bitmap) {\n            const handleRendered = () => this._activateNextScreenData();\n            return (\n                <Bitmap\n                    key={key}\n                    className={element.className}\n                    src={element.src}\n                    alt={element.alt}\n                    onComplete={handleRendered}\n                />\n            );\n        }\n\n        // otherwise, just activate the next element\n        this._activateNextScreenData();\n        return null;\n    }\n\n    // renders the final, interactive element to the screen\n    private _renderStaticElement(element: any, key: number): ReactElement {\n        const className = element.className || \"\";\n        const handleRendered = () => {\n            this._setElementState(element.id, ScreenDataState.Done);\n        };\n\n        if (element.type === ScreenDataType.Text) {\n            // \\0 is the ASCII null character to ensure empty lines aren't collapsed\n            // https://en.wikipedia.org/wiki/Null_character\n            const text = element.text.length ? element.text : \"\\0\";\n            return (\n                <Text\n                    key={key}\n                    className={className}\n                    text={text}\n                    onRendered={handleRendered}\n                />\n            );\n        }\n\n        // link\n        if (element.type === ScreenDataType.Link) {\n            return (\n                <Link\n                    key={key}\n                    text={element.text}\n                    target={element.target}\n                    className={className}\n                    onClick={this._handleLinkClick}\n                    onRendered={handleRendered}\n                />\n            );\n        }\n\n        // bitmap\n        if (element.type === ScreenDataType.Bitmap) {\n            const onComplete = () => {\n                // this._activateNextScreenData();\n                this._setElementState(element.id, ScreenDataState.Done);\n            };\n            return (\n                <Bitmap\n                    key={key}\n                    className={className}\n                    src={element.src}\n                    alt={element.alt}\n                    onComplete={onComplete}\n                    autocomplete={true}\n                />\n            );\n        }\n\n        // prompt\n        if (element.type === ScreenDataType.Prompt) {\n            return (\n                <Prompt\n                    key={key}\n                    className={className}\n                    disabled={!!this.state.activeDialogId}\n                    prompt={element.prompt}\n                    commands={element.commands}\n                    onCommand={this._handlePromptCommand}\n                />\n            );\n        }\n\n        // prompt\n        if (element.type === ScreenDataType.Toggle) {\n            return (\n                <Toggle\n                    key={key}\n                    className={className}\n                    states={element.states}\n                />\n            );\n        }\n\n        return null;\n    }\n\n    private _changeScreen(targetScreen: string): void {\n        // todo: handle missing screen\n        // unload the current screen first\n        this._unloadScreen();\n\n        // active the first element in the screen's content collection\n        const screen = this._getScreen(targetScreen);\n        const activeElement = screen.content[0];\n        activeElement.state = ScreenDataState.Active;\n\n        this.setState({\n            activeScreenId: targetScreen,\n            activeElementId: activeElement.id,\n            status: AppStatus.Active,\n        });\n    }\n\n    private _setElementState(id: string, state: ScreenDataState): void {\n        const screen = this._getScreen(this.state.activeScreenId);\n        const content = screen.content.find(element => element.id === id);\n\n        // only change the state if we need to\n        if (content && (content.state !== state)) {\n            content.state = state;\n        }\n;   }\n\n    private _unloadScreen(): void {\n        // go through the current screen elements, setting\n        // their states to ScreenDataState.Ready\n        const screen = this._getScreen(this.state.activeScreenId);\n        screen.content.forEach(element => {\n            element.state = ScreenDataState.Unloaded;\n        });\n    }\n\n    private _getScreenDataById(id: string): any {\n        const screen = this._getScreen(this.state.activeScreenId);\n        return screen.content.find(element => element.id === id);\n    }\n\n    // find the currently active element and, if possible, activate it\n    private _activateNextScreenData(): void {\n        const screen = this._getScreen(this.state.activeScreenId);\n        const activeIndex = screen.content.findIndex(element => element.state === ScreenDataState.Active);\n\n        // nothing is active\n        if (activeIndex === -1) {\n            return;\n        }\n\n        // we're done with this element now\n        screen.content[activeIndex].state = ScreenDataState.Done;\n\n        // we're at the end of the array so there is no next\n        if (activeIndex === screen.content.length - 1) {\n            // todo: indicate everything's done\n            this.setState({\n                activeElementId: null,\n                status: AppStatus.Done,\n            });\n\n            return;\n        }\n\n        // otherwise, activate the next one\n        screen.content[activeIndex + 1].state = ScreenDataState.Active;\n\n        // todo: indicate everything's done\n        this.setState({\n            activeElementId: screen.content[activeIndex + 1].id,\n        });\n    }\n\n    private _getActiveScreenData(): ScreenData {\n        const screen = this._getScreen(this.state.activeScreenId);\n        const activeIndex = screen.content.findIndex(element => element.state === ScreenDataState.Active);\n\n        // is something active?\n        if (activeIndex > -1) {\n            return screen.content[activeIndex];\n        }\n\n        // otherwise set & return the first element\n        const firstData = screen.content[0];\n\n        // unless that element is already done or not yet loaded\n        if (firstData.state === ScreenDataState.Done || firstData.state === ScreenDataState.Unloaded) {\n            return null;\n        }\n\n\n        firstData.state = ScreenDataState.Active;\n        return firstData;\n    }\n\n    private _setActiveScreenDataByIndex(index: number): void {\n        const screen = this._getScreen(this.state.activeScreenId);\n        screen.content[index].state = ScreenDataState.Active;\n    }\n\n    private _toggleDialog(dialogId?: string): void {\n        // TODO: check if targetDialog is a valid dialog\n        this.setState({\n            activeDialogId: dialogId || null,\n        });\n    }\n\n    private _handlePromptCommand(command: string, args?: any) {\n        // handle the various commands\n        if (!args || !args.type) {\n            // display an error message\n            return;\n        }\n\n        switch (args.type) {\n            case \"link\":\n                // fire the change screen event\n                args.target && this._changeScreen(args.target);\n                break;\n\n            case \"dialog\":\n                args.target && this._toggleDialog(args.target);\n                break;\n\n            case \"console\":\n                console.log(command, args);\n                break;\n\n            default:\n                // throw an error message\n                break;\n        }\n    }\n\n    private _renderDialog(): ReactElement {\n        const { activeDialogId, dialogs, } = this.state;\n\n        if (!activeDialogId) {\n            return null;\n        }\n\n        const dialog = dialogs.find(element => element.id === activeDialogId);\n        if (!dialog) {\n            return null;\n        }\n\n        const handleClose = () => this._toggleDialog();\n\n        return (\n            <Modal\n                text={dialog.content}\n                onClose={handleClose}\n            />\n        );\n    }\n\n    private _handleTeletypeNewLine(): void {\n        // TODO: handle lineheight/scrolling\n        // const ref = this._containerRef;\n        void 0;\n        // console.log(\"scrolling!\", ref);\n        // const lineheight = this.props.measurements.lineHeight;\n        // if (ref) {\n        //     ref.current.scrollTop += lineheight;\n        // }\n    }\n\n    private _handleLinkClick(target: string | any[], shiftKey: boolean): void {\n        // if it's a string, it's a screen\n        if (typeof target === \"string\") {\n            this._changeScreen(target);\n            return;\n        }\n\n        // otherwise, it's a LinkTarget array\n        const linkTarget = (target as any[]).find(element => element.shiftKey === shiftKey);\n        if (linkTarget) {\n            // perform the appropriate action based on type\n            // TODO: type-check the object\n            if (linkTarget.type === \"dialog\") {\n                this._toggleDialog(linkTarget.target);\n                return;\n            }\n\n            if (linkTarget.type === \"link\") {\n                this._changeScreen(linkTarget.target);\n                return;\n            }\n        }\n    }\n}\n\nexport default Phosphor;\n","import React, { Component, ReactElement } from \"react\";\n\n// css\nimport \"./style.scss\";\n\ninterface TeletypeProps {\n    text: string; // text to animate\n    className?: string; // css class\n    autostart?: boolean; // start animating immediately? default = true\n    autocomplete?: boolean; // skip animating and instead fully render? default = false\n    speed?: number; // optional animation speed in ms; default = 5\n\n    onComplete: () => void; // event called on completion\n    onNewLine?: () => void; // event called when the cursor is moved to a new line\n}\n\ninterface TeletypeState {\n    index: number;\n    char: number;\n    active: boolean;\n    done: boolean;\n    paused: boolean;\n}\n\nclass Teletype extends Component<TeletypeProps, TeletypeState> {\n    private _cursorInterval = 5;\n    private _animateTimerId: number = null;\n    private _cursorRef: React.RefObject<HTMLElement> = null;\n    private _cursorY: number = null;\n\n    constructor(props: TeletypeProps) {\n        super(props);\n\n        this._cursorRef = React.createRef<HTMLElement>();\n        this._cursorY = 0;\n\n        const done = !!props.autocomplete;\n        const paused = props.autostart === false;\n\n        this._cursorInterval = props.speed || this._cursorInterval;\n\n        this.state = {\n            index: 0,\n            char: 0,\n            active: false,\n            done,\n            paused,\n        };\n\n        this._animate = this._animate.bind(this);\n        this._updateState = this._updateState.bind(this);\n    }\n\n    public render(): ReactElement {\n        const { text, className } = this.props;\n        const { char, done, active, } = this.state;\n\n        const visible = text.substr(0, char); // already rendered\n        const cursor = text.substr(char, 1) || \" \"; // \" \" ensures the curosr is briefly visible for line breaks\n        const hidden = text.substr(char + 1); // to be rendered\n\n        if (!active || done) {\n            return null;\n        }\n\n        const css = [\"__teletype__\", className ? className : null].join(\" \").trim();\n\n        return (\n            <div className={css}>\n                <span className=\"visible\">{visible}</span>\n                <span className=\"cursor\" ref={this._cursorRef}>{cursor}</span>\n                <span className=\"hidden\">{hidden}</span>\n            </div>\n        );\n    }\n\n    public componentDidMount(): void {\n        const { paused, done } = this.state;\n\n        // if autocomplete is on, we can skip to the end\n        if (done) {\n            this._onComplete();\n            return;\n        }\n\n        // ready to go\n        if (!paused) {\n            this.setState({\n                active: true,\n            }, () => this._animate());\n        }\n    }\n\n    public componentDidUpdate(prevProps: TeletypeProps, prevState: TeletypeState): void {\n        if (!prevState.done && this.state.done) {\n            this._onComplete();\n        }\n\n\n        if (this.state.done) {\n            return;\n        }\n\n        this._animate();\n    }\n\n    public componentWillUnmount(): void {\n        if (this._animateTimerId !== null) {\n            clearTimeout(this._animateTimerId);\n            this._animateTimerId = null;\n        }\n    }\n\n    private _animate(): void {\n        this._clearAnimateTimer();\n\n        if (this.state.paused) {\n            return;\n        }\n\n        // track the current active line\n        this._getCursorPosition();\n\n        // setTimeout is preferred over requestAnimationFrame so the interval\n        // can be specified -- we can control how janky it looked; requestAnimationFrame\n        // results in animation that's much to smooth for our purposes.\n        this._animateTimerId = window.setTimeout(this._updateState, this._cursorInterval);\n    }\n\n    private _getCursorPosition(): void {\n        const { onNewLine } = this.props;\n        // get the cursorRef\n        const ref = this._cursorRef;\n        let y = this._cursorY;\n\n        if (ref && ref.current) {\n            const node = ref.current;\n            const top = node.offsetTop;\n            if (y !== top) {\n                // new line\n                this._cursorY = top;\n                onNewLine && onNewLine();\n            }\n        }\n    }\n\n    private _clearAnimateTimer(): void {\n        if (this._animateTimerId !== null) {\n            window.clearTimeout(this._animateTimerId);\n            this._animateTimerId = null;\n        }\n    }\n\n    private _updateState(): void {\n        const { text, } = this.props;\n        const {\n            char,\n            active,\n            done,\n            paused,\n        } = this.state;\n\n        if (done) {\n            return;\n        }\n\n        // let nextIndex = index;\n        let nextChar = char;\n        let nextActive = active;\n        let nextDone = done;\n        let nextPaused = paused;\n\n        // if we're not active, we are now!\n        if (!nextActive) {\n            nextActive = true;\n        }\n\n        // if char is less that the current string, increment it\n        if (char < text.length) {\n            nextChar = char + 1;\n        } else {\n            nextActive = false;\n            nextDone = true;\n        }\n\n        // update state\n        this.setState({\n            // index: nextIndex,\n            char: nextChar,\n            active: nextActive,\n            done: nextDone,\n            paused: nextPaused,\n        });\n    }\n\n    private _onComplete(): void {\n        const { onComplete, } = this.props;\n        onComplete && onComplete();\n    }\n}\n\nexport default Teletype;\n","import React, { SFC, useEffect } from \"react\";\n\nimport \"./style.scss\";\n\n// enum LinkTargetType {\n//     Unknown = 0,\n//     Screen,\n//     Dialog,\n// }\n\ninterface LinkTarget {\n    target: string;\n    type: any;\n    locked?: boolean;\n}\n\nexport interface LinkProps {\n    text: string;\n    target: string | LinkTarget[];\n    className?: string;\n    onClick?: (target: string | LinkTarget[], shiftKey: boolean) => void;\n    onRendered?: () => void;\n}\n\nconst Link: SFC<LinkProps> = (props) => {\n    const { text, target, className, onClick, onRendered } = props;\n    const css = [\"__link__\", className ? className : null].join(\" \").trim();\n\n    // events\n    const handleClick = (e: React.MouseEvent<HTMLSpanElement>) => (onClick && onClick(target, e.shiftKey));\n    const handleRendered = () => (onRendered && onRendered());\n\n    // this should fire on mount/update\n    useEffect(() => handleRendered());\n\n    return (\n        <span className={css} onClick={handleClick}>{text}</span>\n    );\n};\n\nexport default Link;\n","import React, { SFC, useEffect } from \"react\";\n\nexport interface TextProps {\n    text: string;\n    className?: string;\n    onRendered?: () => void;\n}\n\nconst Text: SFC<TextProps> = (props) => {\n    const { text, className, onRendered } = props;\n    const css = [\n        \"__text__\",\n        className ? className : null,\n    ].join(\" \").trim();\n\n    // events\n    const handleRendered = () => (onRendered && onRendered());\n\n    // this should fire on mount/update\n    useEffect(() => handleRendered());\n\n    return <div className={css}>{text}</div>;\n};\n\nexport default Text;\n","import React, { Component, RefObject, ReactElement, } from \"react\";\nimport \"./style.scss\";\n\nexport interface BitmapProps {\n    src: string;\n    className?: string;\n    alt?: string;\n    autocomplete?: boolean;\n    onComplete: () => void; // event called on completion\n}\n\ninterface BitmapState {\n    loading: boolean;\n    image: HTMLImageElement;\n}\n\nconst TICK = 150;\n// ersatz Fibonacci sequence\nconst STEPS = [\n    0.01,\n    0.02,\n    0.03,\n    0.05,\n    0.08,\n    0.13,\n    0.21,\n    0.34,\n    0.55,\n    0.89,\n    1.00,\n];\n\nclass Bitmap extends Component<BitmapProps, BitmapState> {\n    private _canvasRef: RefObject<HTMLCanvasElement> = null;\n    private _animateTimerId: number = null;\n    private _currentStep = 0;\n\n    constructor(props: BitmapProps) {\n        super(props);\n\n        this._canvasRef = React.createRef<HTMLCanvasElement>();\n        const loading = !this.props.autocomplete;\n\n        this.state = {\n            loading,\n            image: new Image(),\n        };\n    }\n\n    public render(): ReactElement {\n        const { className } = this.props;\n        const { loading } = this.state;\n        const css = [\"__image__\", className ? className : null].join(\" \").trim();\n\n        return (\n            <div className={css}>\n                {loading && <div className=\"progressbar\" />}\n                <canvas ref={this._canvasRef} />\n            </div>\n        );\n    }\n\n    public componentDidMount(): void {\n        this._loadImage();\n    }\n\n    private _resampleImage(resolution: number): void {\n        const { image, } = this.state;\n        const canvas = this._canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n\n        const w = image.width;\n        const h = image.height;\n\n        const dw = w * resolution;\n        const dh = h * resolution;\n\n        // trun off smoothing to ensure it's pixelated\n        ctx.imageSmoothingEnabled = false;\n        // shrink the image\n        ctx.drawImage(image, 0, 0, dw, dh);\n        // then draw the above bitmap at then expected image size without resampling\n        ctx.drawImage(canvas, 0, 0, dw, dh, 0, 0, w, h);\n    }\n\n    private _clearAnimationTimer = () => {\n        if (this._animateTimerId) {\n            window.clearInterval(this._animateTimerId);\n            this._animateTimerId = null;\n        }\n    };\n\n    private _animate(): void {\n        const { onComplete, } = this.props;\n\n        this._clearAnimationTimer();\n        this._animateTimerId = window.setInterval(() => {\n            if (this._currentStep < STEPS.length) {\n                this._resampleImage(STEPS[this._currentStep]);\n                this._currentStep++;\n            } else {\n                this._clearAnimationTimer();\n                onComplete && onComplete();\n            }\n        }, TICK);\n    }\n\n    private _loadImage(): void {\n        const { autocomplete, onComplete, src, } = this.props;\n        const { image } = this.state;\n        const canvas = this._canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n\n        if (ctx && image) {\n            image.onload = () => {\n                // resize the canvas element\n                const w = image.width;\n                const h = image.height;\n\n                // todo: max dimensions\n                // make sure width is no larger than container width\n                canvas.width = w;\n                canvas.height = h;\n\n                if (!autocomplete) {\n                    this.setState({\n                        loading: false,\n                    }, () => this._animate());\n                } else {\n                    ctx.drawImage(image, 0, 0);\n                    onComplete && onComplete();\n                }\n            };\n            image.src = src;\n        }\n    }\n}\n\nexport default Bitmap;\n","import React, { SFC, useEffect, useRef, RefObject, useState, } from \"react\";\n\n// css\nimport \"./style.scss\";\n\nexport interface PromptProps {\n    prompt?: string;\n    commands?: any[];\n    className?: string;\n    disabled?: boolean;\n\n    onCommand?: (command: string, action: string) => void;\n    onEscape?: () => void;\n    onRendered?: () => void;\n}\n\nexport const PROMPT_DEFAULT = \"$> \";\n\nconst Prompt: SFC<PromptProps> = (props) => {\n    const { disabled, prompt, className, commands, onCommand, onRendered, } = props;\n    const ref: RefObject<HTMLSpanElement> = useRef();\n    const css = [\n        \"__prompt__\",\n        disabled ? \"disabled\" : null,\n        className ? className : null,\n    ].join(\" \").trim();\n\n    const [value, setValue] = useState(\"\");\n\n    // events\n    const handleFocus = () => ref.current.focus();\n\n    const handleCommand = () => {\n        if (!onCommand) {\n            return;\n        }\n\n        const command = commands.find(element => element.command === value);\n        setValue(\"\");\n\n        if (command) {\n            onCommand(value, command.action);\n        }\n    };\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n        if (disabled) {\n            setValue(\"\");\n            return;\n        }\n\n        e.preventDefault();\n\n        const key = e.key.toLowerCase();\n        switch (key) {\n            case \"backspace\":\n                value.length && setValue(value.slice(0, -1));\n                break;\n\n            case \"enter\":\n                handleCommand();\n                break;\n\n            default:\n                // support alphanumeric, space, and limited puntuation only\n                const re = /[a-z0-9,.<>/?[\\]{}'\";:*&^%$#@!~]/\n                if (key.length === 1 && key.match(re)) {\n                    setValue(value + key);\n                }\n                break;\n        }\n    };\n\n    // render effects\n    useEffect(() => {\n        // mount\n        onRendered && onRendered();\n        document.addEventListener(\"keydown\", handleKeyDown);\n\n        // unmount\n        return () => document.removeEventListener(\"keydown\", handleKeyDown);\n    });\n\n    return (\n        <div className={css} onClick={handleFocus}>\n            {prompt && <span className={\"prompt\"}>{prompt}</span>}\n            <span className={\"input\"} ref={ref}>{value}</span>\n        </div>\n    );\n};\n\nexport default Prompt;\n","import React, { SFC, useCallback, useEffect, useState } from \"react\";\n\nimport \"./style.scss\";\n\nexport interface ToggleState {\n    text: string;\n    active?: boolean;\n}\n\nexport interface ToggleProps {\n    states: ToggleState[];\n    className?: string;\n    onRendered?: () => void;\n    onClick?: () => void;\n}\n\nconst Toggle: SFC<ToggleProps> = (props) => {\n    const { className, states, onRendered } = props;\n    const css = [\n        \"__toggle__\",\n        className ? className : null,\n    ].join(\" \").trim();\n\n    // find the active state\n    const state = states.find(element => element.active === true);\n    const text = (state && state.text) || \"\";\n\n    // set the new active one\n    const [active, setActive] = useState(state);\n\n    // events\n    const handleRendered = () => (onRendered && onRendered());\n    const handleClick = useCallback(() => {\n        if (active) {\n            // get the active index;\n            const index = states.findIndex(element => element === active);\n            // unset everything\n            states.forEach(element => element.active = false);\n            // set the next active element\n            const next = states[index + 1 === states.length ? 0 : index + 1];\n            next.active = true;\n            setActive(next);\n        }\n    }, [states, active, setActive]);\n\n    // this should fire on mount/update\n    useEffect(() => handleRendered());\n\n    return <div className={css} onClick={handleClick}>{text}</div>;\n};\n\nexport default Toggle;\n","import React, { SFC, useEffect, useCallback } from \"react\";\n\nimport \"./style.scss\";\n\nexport interface ModalProps {\n    text: string | string[];\n    className?: string;\n    onClose: () => void;\n}\n\nconst Modal: SFC<ModalProps> = (props) => {\n    const { text, className, onClose } = props;\n    const css = [\n        \"__modal__\",\n        className ? className : null,\n    ].join(\" \").trim();\n\n    const renderContent = () => {\n        const content = (typeof text === \"string\") ? [text] : text;\n        return content.map((element, index) => <p key={index}>{element}</p>);\n    }\n\n    // add a keyhandler\n    const handleKeyDown = useCallback((e: KeyboardEvent) => {\n        e.preventDefault();\n\n        const key = e.key.toLowerCase();\n\n        switch (key) {\n            case \"enter\":\n            case \"escape\":\n                onClose && onClose();\n                break;\n\n            default:\n                break;\n        }\n    }, [onClose]);\n\n    useEffect(() => {\n        // mount\n        document.addEventListener(\"keydown\", handleKeyDown);\n\n        // unmount\n        return () => document.removeEventListener(\"keydown\", handleKeyDown);\n    });\n\n    return (\n        <section className={css} onClick={onClose}>\n            <div className=\"content\">\n                {renderContent()}\n            </div>\n        </section>\n    );\n};\n\nexport default Modal;\n","import React, { FC } from \"react\";\nimport \"./style.scss\";\n\nconst Scanlines: FC = () => <section className=\"__scanlines__\" />;\n\nexport default Scanlines;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Phosphor from \"./components/Phosphor\";\n\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n    <React.StrictMode>\n        <Phosphor />\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}